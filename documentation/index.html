<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Datepedia-pwa documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="./images/favicon.ico">
	   <link rel="stylesheet" href="./styles/style.css">
        <link rel="stylesheet" href="./styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="./" class="navbar-brand">Datepedia-pwa documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content getting-started">
                   <div class="content-data">

<h1 id="what-does-Datepedia-pwa-do">What does Datepedia-pwa do?</h1>
<ul>
<li>You can set two different dates, then calculate how many days have passed between them. But also you will be able to know what happenned on such days and month through History</li>
</ul>
<h1 id="what-have-i-learned-or-implemented-while-developing-Datepedia-pwa">what have I learned or implemented while developing Datepedia-pwa?</h1>
<ul>
<li>Used promises to get used to async programming. As Angular´s httpClient get() method provides async request, I used Promises to ensure I obtain and control data flow the way I need.</li>
<li>I also provide a branch with the same code below, but using async/await to see the differences. Async await provides a cleaner code since the behavior is more similar to what we see on synchronous code</li>
<li>Date inputs are ordered. </li>
<li>Random results from the api for each date, ensuring can´t be repeated.Promesas, cambio d efecha ordenada, resultados aleatorios</li>
<li>Used interfaces to create custom data type to be shown to the user, it makes data retrieved by the API easier to manipulate and ensure integrity and maintenance</li>
<li>Used angular animations</li>
<li>Reactive forms with built-in and custom validators. For example, custom validator is created to ensure, if user inputs same exact date, form will be invalid.</li>
<li>Basic testing with karma and jasmine, maybe learn Protactor in the future if I find easier and faster to automate.</li>
<li>Form styles found here <a href="https://codepen.io/prathkum/pen/OJRvVzY">https://codepen.io/prathkum/pen/OJRvVzY</a></li>
<li>You can enter the dates in the order you want. It was kind of logic challenge</li>
<li>Customized 404 error page. Code snippet used available here <a href="https://codepen.io/Navedkhan012/pen/vrWQMY">https://codepen.io/Navedkhan012/pen/vrWQMY</a></li>
<li>If requested date has same day and month but different year (e.g: &quot;2021-04-06&quot; and &quot;2022-04-06&quot;), modal header will properly show date one time instead of two. Has no sense to show &quot;Some events happened on November 03 and November 03&quot;</li>
<li>For the same reason and in the same case from above, we control the async requests to the API to ensure we make only a request instead of two. We don´t need to request and show two times for a date with same day and month. With one object with events is enough.</li>
</ul>
<h1 id="notes-for-developers">NOTES FOR DEVELOPERS</h1>
<p>1 -  </p>
<div><pre class="line-numbers"><code class="language-none">with Viewchild, we bind two properties on the child component

 firstDateToShowWhenFlipped

 lastDateToShowWhenFlipped

This are changed on each onSubmit() method like specified below

 this.showDays.firstDateToShowWhenFlipped=this._dates.convertArrayOfNumbersIntoString(firstOrderedDate);

 this.showDays.lastDateToShowWhenFlipped=this._dates.convertArrayOfNumbersIntoString(lastOrderedDate);

These way we ensure they will be properly changed and shown with correct values each time they are changed.

Other way of sending data to child components is like we did on the HTML template this way, with valuetotalDays and isDivFlipped, which are properties on the child component which receive data from totalDays and isFlipped, which are properties on this current component.

    &lt;app-show-days [valueTotalDays]=totalDays [isDivFlipped]=&quot;isFlipped&quot; #showDaysComponentTemplateReference&gt;&lt;/app-show-days&gt;


In both ways, the child component properties must be using the &#64;Input() decorator to &quot;listen&quot;.</code></pre></div><p>2 - </p>
<div><pre class="line-numbers"><code class="language-none">arrayOfEventsToShow is used here on modal component HTML template
to show the events on a certain date.

I have declared it as &#39;any&#39; because in order to use it on the template
is easier to access properties. With a more strict type was giving problems.
//TODO look for a better solution

It receives its value from parent component show-days-component,
through a property of parent component called arrayOfObjectsWithEvents

Both are binded on show-days-component HTML template
and also value is assigned inside that component´s .ts code
on the _callApi service´s getEventsPromise() method</code></pre></div><p>3 - </p>
<div><pre class="line-numbers"><code class="language-none"> firstDateToShowWhenFlipped

and

 lastDateToShowWhenFlipped

These 2 string properties will be used to show dates when this component is flipped.

for example: &quot;total days between 2021-06-01 and 2021-07-02 are... &quot;

As the order to show dates can be different on this component than on modal,
because year is not present, I also will declare 2 new properties:

 firstDateToShowOnModal

 lastDateToShowOnModal</code></pre></div><p>4 - </p>
<div><pre class="line-numbers"><code class="language-none"> firstDateToShowOnModal

and 

 lastDateToShowOnModal

are used to pass its values to child component app-modal, then values can be shown on the modal.

These two properties receive their values from date1 and date2 properties from the _dates service.

We use them because service is private, so can´t use it on the template (outside the class), so we need properties with public visibility in order to be used on component´s HTML template.

As date and date 2 have a number[] type, we will convert them to string with a custom method created on the service</code></pre></div><p>5 - </p>
<div><pre class="line-numbers"><code class="language-none"> arrayNumberWithFirstDateToBeSentToApi

and

 arrayNumberWithLastDateToBeSentToApi

This two properties will be sent to the API on the proper order.

We need them because the API requires them to be numbers, so we can´t simply send the same string properties we declared above, to send dates to modals.

Also array of numbers can&#39;t be directly piped on the template as we can do with strings, so for the moment I find easier to do this way: 

  -string properties with dates to be shown on modals, 
  -array of numbers with dates to be sent to API</code></pre></div><p>6 - </p>
<div><pre class="line-numbers"><code class="language-none">Maybe this arrayOfObjectsWithEvents could have been declared as customEvent type, with our own interface we have created, but I need to use the push() method on it so I find it better to be declared as array of Objects for now.

The value from this property will be sent to app-modal child component, 
to the property called arrayOfEventsToShow</code></pre></div><p>7 - </p>
<div><pre class="line-numbers"><code class="language-none">To show dates on modal, we need a different logic than the one we use to order the complete dates.

Why? On modal we show no year. We will only show month and day, so a valid order for:

  2021-06-04 (second date to be shown)

and

  2020-08-02 (first date to be shown)

would not be a valid order for

  06-04 (first date to be shown)

and

  08-02 (second date to be shown)

We can see order is different because we don´t take the year into account and that changes everything.

So we can´t simply do

  this.firstDateToShowOnModal = this._dates.convertArrayOfNumbersIntoString(date1);

  this.lastDateToShowOnModal = this._dates.convertArrayOfNumbersIntoString(date2);

Also note that we can´t either show on modal the complete dates 
because we are not showing events from e.g. 2021-06-04, but events from what happened on any 06-04 from any year.

We must take month and day from each date and then order then 
having only those values of month and day in mind.</code></pre></div><p>8 -</p>
<div><pre class="line-numbers"><code class="language-none">Here we also need to order dates, as on convertDatesToModal().

But here I decided to create two new local string variables to store the string dates to send dates to the API, despite using the same string class properties we created to send dates to modal.

These local variables are 

  stringWithFirstDateToBeSentToApi

and 

  stringWithLastDateToBeSentToApi

Reason is, logic here is similar but different than on convertDatesToModal().

Here we don&#39;t need to show them on a template, just be used to be converted to Date objects and then be ordered, like also did on convertDatesToModal().

The array numbers we get from the _dates service can`t be converted to the Date objects we need to order dates, but that can be done with string properties.

But using the same string properties we have to show dates on modal, could cause flow not working fine. So that is why I decided to create different local string properties.

As said, we need Date objects to order dates, but we also need dates as number type (dates come as an array of numbers from the service so that work is done) to be sent to the API because this API requires them to be number type.

I am aware that the code used to order dates on this method and on convertDatesToModal() is almost the same, so it can be refactored, but for now I let this way.</code></pre></div><p>9 - </p>
<div><pre class="line-numbers"><code class="language-none">we use a promise to ensure we control the async request done by _http:get() method which is called inside _dates service.

So, once we have 1st result with events corresponding to the 1st date, and added them as first element of an array to store the events of the 2 dates,we make the 2nd request (if month or day are different,otherwise we need to show results only one time).

Why do we only 2 requests if month or day are different? 

e.g. if we have &quot;results for november 05&quot; ,it has no sense to show
    -5 results for november 05 (first request)
    -and another 5 results again for november 05 (another request, which will be done only if date or month are different)</code></pre></div><p>10 -</p>
<div><pre class="line-numbers"><code class="language-none">getEventsPromise() will be used on show-days-component.

PARAMETERS:month and day of the date to search

We need it to make a promise -or with async/await, check branch async-await-, to be sure we have the data returned for the first date before requesting for second date, and properly order them </code></pre></div><p>11 - </p>
<div><pre class="line-numbers"><code class="language-none">we can´t use an RXJS operator  to catch only 5 random results of retrieved data, take() operator here doesn&#39;t work because values should be emitted by the API one by one, and all events for a date are all emitted together.

As said, we will use dataToShow property, which is customEvents type, to store filtered data, then pass it to show-days-component&#39;s property called arrayOfObjectsWithEvents, and through a viewchild, pass the value to modal child component and be able to show it.

To handle error, we use a property called modalError with custom type error interface called customError, on that error we set the error response values we are interested in.

Also use the reject() keyword which, like resolve() is like a return. It is used to handle errors, resolve() is to handle sucessful request </code></pre></div><p>12 -</p>
<div><pre class="line-numbers"><code class="language-none">getFiveRandomElementsOfArray() will implement the logic to get 5 random events once all results of the API are requested 

OTHER METHODS CALLED: 

  -isUsedIndex

PARAMETERS: 

  -the data object returned by the api, it contains, among others,
  an events property which is an array with events

RETURNS a randomEvents custom type</code></pre></div><p>13 - </p>
<div><pre class="line-numbers"><code class="language-none">OVERVIEW EXPLANATION:

On two given dates, for example, 

    2004-04-06 and 2018-05-09

we will calculate the amount of days between them this way:

    - The days for first and last year with a method called calcFirstAndLastYearDays()

    - The days between 2005 and 2017 will be calculated on calcDaysBetweenYears()

    - The total days will be put together on calculateTotalDaysBetweenDates()</code></pre></div><p> 14 - </p>
<div><pre class="line-numbers"><code class="language-none">to order dates, we must prevent it could happen user sets the second date is older (e.g. first date 2018 and second date 2004).

We will allow that, we will properly order and calculate them. 
I find it better than forcing user to set dates in a &quot;correct&quot; order (e.g &quot;2nd date must be higher than 1st&quot; I dont like that)

As date1 and date2 will be an array of numbers with year, month and day separated, we will store both arrays on orderedDatesArray, and as it is an array of arrays, we declare it as number[][]</code></pre></div><p>15 - </p>
<div><pre class="line-numbers"><code class="language-none">    convertArrayOfNumbersIntoString()

This method does the reverse operation of splitStringDateIntoArrayOfNumbers.

To show on modal and properly play with datepipes we need the dates as string, so we reverse the dates as array of numbers we have operated with, and revert back to strings.

I realised perhaps it would have been a better idea to have the string dates we get from the form at home-component, 
  
    firstYearToCheckDateString

and 

    lastYearToCheckDateString
  
as properties of this service and not as home-component-properties.

Now perhaps this method would not have been neccessary, and would be a better designed app. But I am here to learn :)

Also maybe we would save some inherit of properties from parent to child components

PARAMETERS: The array of numbers to convert to String
RETURNS: the Date as string</code></pre></div><p>16 -</p>
<div><pre class="line-numbers"><code class="language-none">    isLeapYearCheck()

We need to know if year is Leap or not, to add one more day to the year in that case

PARAMETERS: The year (only the year), to be checked

RETURNS: true if is Leap, otherwise false</code></pre></div><p>17 - </p>
<div><pre class="line-numbers"><code class="language-none">    calcFirstAndLastYearDays()

PARAMETERS will be the full date given as array of numbers with year, month and date

RETURNS: an array of numbers, with two number elements:
    -days from 01/01 to given value (for example, days between 01/01 from 04/07/2015)
    -days from given value to 31/12 for example, days from 04/07/2015 to 31/12 same year).
    -If year is leap, we will add one day to one of the two above results,where february is involved and then must be counted</code></pre></div><p>18 - </p>
<div><pre class="line-numbers"><code class="language-none">First, we calculate 

    daysPassed from 01-01 until selected Date, that will be daysPassed

Then, to get daysRemaining, we substract daysPassed to 365 or 366, depending if year is leap or not

  365 or 366 - daysPassed = daysRemaining

We will return an array with both values: daysPassed and daysRemaining</code></pre></div><p>19 - </p>
<div><pre class="line-numbers"><code class="language-none">    calcDaysBetweenYears()

calculate days between the years of 2 given years (only years), taking into account if it is leap year or not.

    Example: 2006-04-06 and 2018-05-09 
    
this method will calculate the days between 2005 and 2017.

2004 and 2018 days would be calculated by calcFirstAndLastYearDays()  


PARAMETERS:
  the two years (as said, not dates, just the years).

RETURNS localTotalDaysBetweenYears, a number with the total days between the two given years.

20 -

        localTotalDaysBetweenYears variable

    To the name localTotalDaysBetweenYears, I added &quot;local&quot; to clarify between that variable and other variables or properties used on this service, for example the totalDaysBetweenDates property, or the daysBetweenYears variable which is used on calculateTotalDaysBetweenDates(),to avoid name confussions because they are similar.
  
    localTotalDaysBetweenYears stores only the total days between two given years.

    For example between 2004 and 2018, it will store total days between 2005 and 2017, and its value will be returned to a variable with similar name called daysBetweenYears inside the method calculateTotalDaysBetweenDates()  

    totalDaysBetweenDates is a service property, and stores the TOTAL days between the two given dates, the final result.

    This local variable will only change if PARAMETERS (years) are different

    Also I considered better to use a local variable and not a property
    which could not exist on another project, this way is more reusable.  </code></pre></div><p>21 - </p>
<div><pre class="line-numbers"><code class="language-none">Now we get the days betweeen minor year +1 and highest given year, that is so because each of the given years` total days will be calculated on calcFirstAndLastYearDays()  
  
e.g: between 2004(minorYear) and 2018 (highestYear) on this method we would iterate between 2005 and 2017.

2004 and 2018 days would be calculated by calcFirstAndLastYearDays()</code></pre></div><p>22 - </p>
<div><pre class="line-numbers"><code class="language-none">    calculateTotalDaysBetweenDates()

This is the method where final result will be produced and stored on the totalDaysBetweenDates property

PARAMETERS the two dates

RETURNS nothing, since the total result will be stored on a service property called totalDaysBetweenDates</code></pre></div><p>23 - </p>
<div><pre class="line-numbers"><code class="language-none">if one year is different from the other, we add the results. 

For example, between 2004-04-06 and 2018-05-09:
    - Days from 2004-04-06 to 2004-31-12 (daysLeftDate1)
    - days between 2007 and 2017 (daysBetweenYears) 
    - Days from 2018-01-01 to 2018-05-09 (daysPassedDate2)

Obviously we always have checked if years are leap or not

If the year is the same, for example, 2004-04-06 and 2004-08-09, we will check if that year is leap, and set the amount of total days accordingly to 365 or 366.

Then to obntain the difference (days passed between one date and another) we substract to 365 or 366 the results of days passed from 01-01 until first given date, adding the days remaning until 31-12 from second given date</code></pre></div>


















                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 0;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'getting-started';
            var COMPODOC_CURRENT_PAGE_URL = 'index.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="./js/libs/custom-elements.min.js"></script>
       <script src="./js/libs/lit-html.js"></script>

       <script src="./js/menu-wc.js" defer></script>
       <script nomodule src="./js/menu-wc_es5.js" defer></script>

       <script src="./js/libs/bootstrap-native.js"></script>

       <script src="./js/libs/es6-shim.min.js"></script>
       <script src="./js/libs/EventDispatcher.js"></script>
       <script src="./js/libs/promise.min.js"></script>
       <script src="./js/libs/zepto.min.js"></script>

       <script src="./js/compodoc.js"></script>

       <script src="./js/tabs.js"></script>
       <script src="./js/menu.js"></script>
       <script src="./js/libs/clipboard.min.js"></script>
       <script src="./js/libs/prism.js"></script>
       <script src="./js/sourceCode.js"></script>
          <script src="./js/search/search.js"></script>
          <script src="./js/search/lunr.min.js"></script>
          <script src="./js/search/search-lunr.js"></script>
          <script src="./js/search/search_index.js"></script>
       <script src="./js/lazy-load-graphs.js"></script>


    </body>
</html>
